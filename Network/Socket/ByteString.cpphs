{-# LANGUAGE CPP, ForeignFunctionInterface #-}

-- |
-- Module      : Network.Socket.ByteString
-- Copyright   : (c) Johan Tibell 2007
-- License     : BSD-style
--
-- Maintainer  : johan.tibell@gmail.com
-- Stability   : experimental
-- Portability : portable
--
-- A module for efficiently transmitting data over sockets. For
-- detailed documentation consult your favorite POSIX socket
-- reference. All functions communicate failures by converting the
-- error number to an 'System.IO.IOError'.
--
-- This module is intended to be imported together with 'Network.Socket' like so:
--
-- > import Network.Socket hiding (send, sendTo, recv, recvFrom)
-- > import Network.Socket.ByteString
--
module Network.Socket.ByteString
    (
     -- * Send data to a socket
     -- | Functions used to transmit a message to another socket.
     send,
     sendAll,
     sendMany,
     sendManyAll,
     sendTo,
     sendAllTo,
     sendManyTo,

     -- * Receive data from a socket
     -- | Functions used to receive messages from a socket, and may be
     -- used to receive data on a socket whether or not it is
     -- connection-oriented.
     recv,
     recv_,
     recvFrom
    ) where

import Control.Monad (liftM, when, zipWithM_)
import qualified Data.ByteString as B
import Data.ByteString (ByteString)
import Data.ByteString.Internal (createAndTrim)
import Data.ByteString.Unsafe (unsafeUseAsCStringLen)
import Data.List (iterate)
import Data.Word (Word8)
import Foreign.C.Error (eINTR, getErrno, throwErrno)
import Foreign.C.Types (CChar, CInt, CSize)
import Foreign.Marshal.Alloc (allocaBytes)
import Foreign.Marshal.Array (allocaArray)
import Foreign.Marshal.Utils (with)
import Foreign.Ptr (Ptr, castPtr, nullPtr, plusPtr)
import Foreign.Storable (Storable(..))
import Network.Socket (SockAddr, Socket(..), sendBufTo, recvBufFrom)
import Network.Socket.ByteString.IOVec
import Network.Socket.ByteString.Internal
import Network.Socket.ByteString.MsgHdr
import Network.Socket.ByteString.SockAddr (pokeSockAddr, sizeOfSockAddr)

#if defined(__GLASGOW_HASKELL__)
import GHC.Conc (threadWaitRead, threadWaitWrite)
# if defined(mingw32_HOST_OS)
import GHC.Handle (readRawBufferPtr, writeRawBufferPtr)
# endif
#else
import System.IO.Unsafe (unsafePerformIO)
#endif

#ifndef CALLCONV
# ifdef WITH_WINSOCK
#  define CALLCONV stdcall
# else
#  define CALLCONV ccall
# endif
#endif

foreign import CALLCONV unsafe "send"
  c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
foreign import CALLCONV unsafe "recv"
  c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt

-- -----------------------------------------------------------------------------
-- Sending

-- | Send data to the socket.  The socket must be connected to a
-- remote socket.  Returns the number of bytes sent.  Applications are
-- responsible for checking that all data has been sent; if only some
-- of the data was transmitted, the application needs to attempt
-- delivery of the remaining data.
send :: Socket      -- ^ Connected socket.
     -> ByteString  -- ^ Data to send.
     -> IO Int      -- ^ Number of bytes sent.
send (MkSocket s _family _stype _protocol _status) xs =
  unsafeUseAsCStringLen xs $ \(str, len) ->
    liftM fromIntegral $
#if defined(__GLASGOW_HASKELL__) && defined(mingw32_HOST_OS)
      writeRawBufferPtr "Network.Socket.ByteString.send" (fromIntegral s) True str 0
                (fromIntegral len)
#else
# if !defined(__HUGS__)
     throwErrnoIfMinus1Retry_repeatOnBlock "send"
        (threadWaitWrite (fromIntegral s)) $
# endif
        c_send s str (fromIntegral len) 0{-flags-}
#endif

-- | Send data to the socket. The socket must be connected to a remote
-- socket.  Unlike 'send', this method continues to send data until
-- either all data has been sent or an error occurs. On error, an
-- exception is raised, and there is no way to determine how much
-- data, if any, was successfully sent.
sendAll :: Socket      -- ^ Connected socket.
        -> ByteString  -- ^ Data to send.
        -> IO ()
sendAll sock bs = do
  sent <- send sock bs
  when (sent < B.length bs) $ sendAll sock (B.drop sent bs)

-- | Send a multi-part message. The given socket must be connected. The data is
-- sent as if the given strings have been concatenated.
sendMany :: Socket        -- ^ Connected socket.
         -> [ByteString]  -- ^ Data to send.
         -> IO Int        -- ^ Number of bytes sent.
sendMany (MkSocket fd _ _ _ _) cs =
  liftM fromIntegral . withIOVec cs $ \(iovsPtr, iovsLen) ->
    throwErrnoIfMinus1Retry_repeatOnBlock "writev"
      (threadWaitWrite (fromIntegral fd)) $
      c_writev (fromIntegral fd) iovsPtr (fromIntegral iovsLen)

-- | Send a multi-part message, ensuring that all the data is sent. The given
-- socket must be connected. The data is sent as if the given strings have been
-- concatenated.
sendManyAll :: Socket        -- ^ Connected socket.
            -> [ByteString]  -- ^ Data to send.
            -> IO ()
sendManyAll sock cs = do
  sent <- sendMany sock cs
  when (sent < totalLength cs) $ sendManyAll sock (remainingChunks sent cs)

-- | Send data to the socket. The recipient can be specified
-- explicitly, so the socket does not have to be (but can be) in a
-- connected state.  Returns the number of bytes sent.
sendTo :: Socket      -- ^ (Possibly) connected socket.
       -> ByteString  -- ^ Data to send.
       -> SockAddr    -- ^ Recipient address.
       -> IO Int      -- ^ Number of bytes sent.
sendTo sock xs addr =
  unsafeUseAsCStringLen xs $ \(str, len) ->
    sendBufTo sock str len addr

-- | Send data to the socket. The recipient is specified explicitly,
-- so the socket does not have to be (but can be) in a connected
-- state.  Unlike 'sendTo', this method continues to send data until
-- either all data has been sent or an error occurs. On error, an
-- exception is raised, and there is no way to determine how much
-- data, if any, was successfully sent.
sendAllTo :: Socket      -- ^ (Possibly) connected socket
          -> ByteString  -- ^ Data to send
          -> SockAddr    -- ^ Recipient address
          -> IO ()
sendAllTo sock xs addr = do
  sent <- sendTo sock xs addr
  when (sent < B.length xs) $ sendAllTo sock (B.drop sent xs) addr

-- | Send a multi-part message on a socket. The recipient can be specified
-- explicitly, so the socket does not have to be (but can be) in a connected
-- state. Continues to send data until either all data has been sent or an
-- error occurs. The data is sent as if the parts have been concatenated.
sendManyTo :: Socket        -- ^ (Possibly) connected socket
           -> [ByteString]  -- ^ Data to send
           -> SockAddr      -- ^ Recipient address
           -> IO ()
sendManyTo sock@(MkSocket fd _ _ _ _) cs addr = do
  sent <- liftM fromIntegral sendManyToInner
  when (sent < totalLength cs) $ sendManyTo sock (remainingChunks sent cs) addr
  where
    sendManyToInner =
      withSockAddr addr                                                   $ \addrPtr            ->
      withIOVec cs                                                        $ \(iovsPtr, iovsLen) ->
      with (MsgHdr addrPtr 16 iovsPtr (fromIntegral iovsLen) nullPtr 0 0) $ \msgHdrPtr          ->
        throwErrnoIfMinus1Retry_repeatOnBlock "sendmsg"
          (threadWaitWrite (fromIntegral fd)) $
          c_sendmsg (fromIntegral fd) msgHdrPtr 0

-- -----------------------------------------------------------------------------
-- Receiving

-- | Receive a message from another socket. The socket must be in a
-- connected state so that the intended recipient is known. Note that
-- the length of the received data can be smaller than the specified
-- maximum length. If the message is longer than the specified length
-- it may be discarded depending on the type of socket. May block
-- until a message arrives.
--
-- When the end of the input stream is reached, returns an empty
-- ByteString.
recv_ :: Socket          -- ^ Connected socket.
      -> Int             -- ^ Maximum number of bytes to receive.
      -> IO ByteString   -- ^ Data received.
recv_ (MkSocket s _ _ _ _) nbytes
    | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.ByteString.recv")
    | otherwise   = createAndTrim nbytes $ recvInner s nbytes

-- | Receive data from the socket. The return value is a 'ByteString'
-- representing the data received.  The maximum amount of data to be
-- received at once is specified by separately.
--
-- Note: For best match with hardware and network realities, the
-- maximum number of bytes to receive should be a relatively small
-- power of 2, for example, 4096.
recv :: Socket                  -- ^ Connected socket.
     -> Int                     -- ^ Maximum number of bytes to receive.
     -> IO ByteString           -- ^ Data received.
recv sock nbytes = do
  ret <- recv_ sock nbytes
  if B.null ret
    then ioError (mkEOFError "Network.Socket.ByteString.recv")
    else return ret

-- | This is a helper function which allows us to loop in the case of EINTR
recvInner :: CInt -> Int -> Ptr Word8 -> IO Int
recvInner s nbytes ptr = do
    len <- liftM fromIntegral $
#if defined(__GLASGOW_HASKELL__) && defined(mingw32_HOST_OS)
        readRawBufferPtr "Network.Socket.ByteString.recvLen" (fromIntegral s) True
                         (castPtr ptr) 0 (fromIntegral nbytes)
#else
# if !defined(__HUGS__)
         throwErrnoIfMinus1Retry_repeatOnBlock "recv"
                (threadWaitRead (fromIntegral s)) $
# endif
                        c_recv s (castPtr ptr) (fromIntegral nbytes) 0{-flags-}
#endif
    if len == -1
      then do
         errno <- getErrno
         if errno == eINTR
           then recvInner s nbytes ptr
           else throwErrno "Network.Socket.ByteString.recv"
      else return len

-- | Receive data from the socket. The return value is a pair @(bytes,
-- address)@ where @bytes@ is a 'ByteString' representing the data
-- received and @address@ is the 'SockAddr' of the socket sending the
-- data.
recvFrom :: Socket                     -- ^ (Possibly) bound\/connected socket.
         -> Int                        -- ^ Maximum number of bytes to receive.
         -> IO (ByteString, SockAddr)  -- ^ Data received and sender address.
recvFrom sock nbytes =
    allocaBytes nbytes $ \ptr -> do
      (len, sockaddr) <- recvBufFrom sock ptr nbytes
      str <- B.packCStringLen (ptr, len)
      return (str, sockaddr)

-- -----------------------------------------------------------------------------
-- Not exported

-- | Suppose we try to transmit a list of chunks @cs@ via a gathering write
-- operation and find that @n@ bytes were sent. Then @remainingChunks n cs@ is
-- list of chunks remaining to be sent.
remainingChunks :: Int -> [ByteString] -> [ByteString]
remainingChunks _ [] = []
remainingChunks i (x:xs) =
  if i < len
    then B.drop i x : xs
    else remainingChunks (i - len) xs
  where
    len = B.length x

-- | @totalLength cs@ is the sum of the lengths of the chunks in the list @cs@.
totalLength :: [ByteString] -> Int
totalLength = sum . map B.length

-- | @withIOVec cs f@ executes the computation @f@, passing as argument a pair
-- consisting of a pointer to a temporarily allocated array of pointers to
-- 'IOVec' made from @cs@ and the number of pointers (@length cs@).
withIOVec :: [ByteString] -> ((Ptr IOVec, Int) -> IO a) -> IO a
withIOVec cs f =
  allocaArray csLen $ \aPtr -> do
    zipWithM_ pokeIov (ptrs aPtr) cs
    f (aPtr, csLen)
  where
    csLen = length cs
    ptrs = iterate (flip plusPtr sizeOfIOVec)
    pokeIov ptr s =
      unsafeUseAsCStringLen s $ \(sPtr, sLen) ->
        poke ptr $ IOVec sPtr (fromIntegral sLen)

-- | @withSockAddr addr f@ executes the computation @f@, passing as argument a
-- pointer to a temporarily allocated block of memory into which @addr@ has
-- been marshalled.
withSockAddr :: SockAddr -> (Ptr SockAddr -> IO a) -> IO a
withSockAddr addr f =
  allocaBytes sizeOfSockAddr $ \addrPtr -> do
    pokeSockAddr addrPtr addr
    f addrPtr
