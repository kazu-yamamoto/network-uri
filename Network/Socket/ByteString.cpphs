{-# LANGUAGE CPP, ForeignFunctionInterface #-}

-- |
-- Module      : Network.Socket.ByteString
-- Copyright   : (c) Johan Tibell 2007
-- License     : BSD-style
--
-- Maintainer  : johan.tibell@gmail.com
-- Stability   : experimental
-- Portability : portable
--
-- A module for efficiently transmitting data over sockets. For
-- detailed documentation consult your favorite POSIX socket
-- reference. All functions communicate failures by converting the
-- error number to an 'System.IO.IOError'.
--
-- This module is intended to be imported together with 'Network.Socket' like so:
--
-- > import Network.Socket hiding (send, sendTo, recv, recvFrom)
-- > import Network.Socket.ByteString
--
module Network.Socket.ByteString
    (
     -- * Send data to a socket
     -- | Functions used to transmit a message to another socket.
     send,
     sendAll,
     sendMany,
     sendManyAll,
     sendTo,
     sendAllTo,

     -- * Receive data from a socket
     -- | Functions used to receive messages from a socket, and may be
     -- used to receive data on a socket whether or not it is
     -- connection-oriented.
     recv,
     recv_,
     recvFrom
    ) where

import Control.Monad (liftM, when, zipWithM_)
import Data.ByteString (ByteString)
import qualified Data.ByteString as B
import Data.Word (Word8)
import Data.ByteString.Internal (createAndTrim)
import Data.ByteString.Unsafe (unsafeUseAsCStringLen)
import Data.List (iterate)
import Foreign.C.Error (eINTR, getErrno, throwErrno)
import Foreign.C.Types (CChar, CInt, CSize)
import Foreign.Marshal.Alloc (allocaBytes)
import Foreign.Marshal.Array (allocaArray)
import Foreign.Ptr (Ptr, castPtr, plusPtr)
import Foreign.Storable (Storable(..))
import Network.Socket (SockAddr, Socket(..), sendBufTo, recvBufFrom)
import Network.Socket.ByteString.Internal
import Network.Socket.ByteString.IOVec

#if defined(__GLASGOW_HASKELL__)
import GHC.Conc (threadWaitRead, threadWaitWrite)
# if defined(mingw32_HOST_OS)
import GHC.Handle (readRawBufferPtr, writeRawBufferPtr)
# endif
#else
import System.IO.Unsafe (unsafePerformIO)
#endif

#ifndef CALLCONV
# ifdef WITH_WINSOCK
#  define CALLCONV stdcall
# else
#  define CALLCONV ccall
# endif
#endif

foreign import CALLCONV unsafe "send"
  c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
foreign import CALLCONV unsafe "recv"
  c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt

-- -----------------------------------------------------------------------------
-- Sending

-- | Send data to the socket.  The socket must be connected to a
-- remote socket.  Returns the number of bytes sent.  Applications are
-- responsible for checking that all data has been sent; if only some
-- of the data was transmitted, the application needs to attempt
-- delivery of the remaining data.
send :: Socket      -- ^ Connected socket.
     -> ByteString  -- ^ Data to send.
     -> IO Int      -- ^ Number of bytes sent.
send (MkSocket s _family _stype _protocol _status) xs =
  unsafeUseAsCStringLen xs $ \(str, len) ->
    liftM fromIntegral $
#if defined(__GLASGOW_HASKELL__) && defined(mingw32_HOST_OS)
      writeRawBufferPtr "Network.Socket.ByteString.send" (fromIntegral s) True str 0
                (fromIntegral len)
#else
# if !defined(__HUGS__)
     throwErrnoIfMinus1Retry_repeatOnBlock "send"
        (threadWaitWrite (fromIntegral s)) $
# endif
        c_send s str (fromIntegral len) 0{-flags-}
#endif

-- | Send data to the socket. The socket must be connected to a remote
-- socket.  Unlike 'send', this method continues to send data until
-- either all data has been sent or an error occurs. On error, an
-- exception is raised, and there is no way to determine how much
-- data, if any, was successfully sent.
sendAll :: Socket      -- ^ Connected socket.
        -> ByteString  -- ^ Data to send.
        -> IO ()
sendAll sock bs = do
  sent <- send sock bs
  when (sent < B.length bs) $ sendAll sock (B.drop sent bs)

-- | Send a multi-part message. The given socket must be connected. The data is
-- sent as if the given strings have been concatenated.
sendMany :: Socket        -- ^ Connected socket.
         -> [ByteString]  -- ^ Data to send.
         -> IO Int        -- ^ Number of bytes sent.
sendMany (MkSocket fd _ _ _ _) ss =
  liftM fromIntegral . allocaArray ssLen $ \aPtr -> do
    pokeIovs aPtr ss
    throwErrnoIfMinus1Retry_repeatOnBlock "writev"
      (threadWaitWrite (fromIntegral fd)) $
      c_writev (fromIntegral fd) aPtr (fromIntegral ssLen)
  where
    pokeIovs :: Ptr IOVec -> [ByteString] -> IO ()
    pokeIovs aPtr = zipWithM_ f ptrs where
      f ptr s =
        unsafeUseAsCStringLen s $ \(sPtr, sLen) ->
          poke ptr $ IOVec sPtr (fromIntegral sLen)
      ptrs = iterate (flip plusPtr sizeOfIOVec) aPtr

    ssLen = length ss

-- | Send a multi-part message, ensuring that all the data is sent. The given
-- socket must be connected. The data is sent as if the given strings have been
-- concatenated.
sendManyAll :: Socket        -- ^ Connected socket.
            -> [ByteString]  -- ^ Data to send.
            -> IO ()
sendManyAll sock ss = do
  n <- sendMany sock ss
  when (n < tlen) $ sendManyAll sock (remaining n ss)
  where
    tlen = sum $ map B.length ss

    remaining _ [] = []
    remaining i (x:xs)
      | i < len   = B.drop i x : xs
      | otherwise = remaining (i - len) xs
      where
        len = B.length x

-- | Send data to the socket. The recipient can be specified
-- explicitly, so the socket does not have to be (but can be) in a
-- connected state.  Returns the number of bytes sent.
sendTo :: Socket      -- ^ (Possibly) connected socket.
       -> ByteString  -- ^ Data to send.
       -> SockAddr    -- ^ Recipient address.
       -> IO Int      -- ^ Number of bytes sent.
sendTo sock xs addr =
  unsafeUseAsCStringLen xs $
    \(str, len) -> sendBufTo sock str len addr

-- | Send data to the socket. The recipient is specified explicitly,
-- so the socket does not have to be (but can be) in a connected
-- state.  Unlike 'sendTo', this method continues to send data until
-- either all data has been sent or an error occurs. On error, an
-- exception is raised, and there is no way to determine how much
-- data, if any, was successfully sent.
sendAllTo :: Socket      -- ^ (Possibly) connected socket
          -> ByteString  -- ^ Data to send
          -> SockAddr    -- ^ Recipient address
          -> IO ()
sendAllTo sock xs addr = do
  sent <- sendTo sock xs addr
  when (sent < B.length xs) $ sendAllTo sock (B.drop sent xs) addr

-- -----------------------------------------------------------------------------
-- Receiving

-- | Receive a message from another socket. The socket must be in a
-- connected state so that the intended recipient is known. Note that
-- the length of the received data can be smaller than the specified
-- maximum length. If the message is longer than the specified length
-- it may be discarded depending on the type of socket. May block
-- until a message arrives.
--
-- When the end of the input stream is reached, returns an empty
-- ByteString.
recv_ :: Socket          -- ^ Connected socket.
      -> Int             -- ^ Maximum number of bytes to receive.
      -> IO ByteString   -- ^ Data received.
recv_ (MkSocket s _ _ _ _) nbytes
    | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.ByteString.recv")
    | otherwise   = createAndTrim nbytes $ recvInner s nbytes

-- | Receive data from the socket. The return value is a 'ByteString'
-- representing the data received.  The maximum amount of data to be
-- received at once is specified by separately.
--
-- Note: For best match with hardware and network realities, the
-- maximum number of bytes to receive should be a relatively small
-- power of 2, for example, 4096.
recv :: Socket                  -- ^ Connected socket.
     -> Int                     -- ^ Maximum number of bytes to receive.
     -> IO ByteString           -- ^ Data received.
recv sock nbytes = do
  ret <- recv_ sock nbytes
  if B.null ret
    then ioError (mkEOFError "Network.Socket.ByteString.recv")
    else return ret

-- | This is a helper function which allows us to loop in the case of EINTR
recvInner :: CInt -> Int -> Ptr Word8 -> IO Int
recvInner s nbytes ptr = do
    len <-
#if defined(__GLASGOW_HASKELL__) && defined(mingw32_HOST_OS)
        readRawBufferPtr "Network.Socket.ByteString.recvLen" (fromIntegral s) True
                         (castPtr ptr) 0 (fromIntegral nbytes)
#else
# if !defined(__HUGS__)
         throwErrnoIfMinus1Retry_repeatOnBlock "recv"
                (threadWaitRead (fromIntegral s)) $
# endif
                        c_recv s (castPtr ptr) (fromIntegral nbytes) 0{-flags-}
#endif
    case fromIntegral len of
         (-1) -> do errno <- getErrno
                    if errno == eINTR
                       then recvInner s nbytes ptr
                       else throwErrno "Network.Socket.ByteString.recv"
         n -> return n

-- | Receive data from the socket. The return value is a pair @(bytes,
-- address)@ where @bytes@ is a 'ByteString' representing the data
-- received and @address@ is the 'SockAddr' of the socket sending the
-- data.
recvFrom :: Socket                     -- ^ (Possibly) bound\/connected socket.
         -> Int                        -- ^ Maximum number of bytes to receive.
         -> IO (ByteString, SockAddr)  -- ^ Data received and sender address.
recvFrom sock nbytes =
    allocaBytes nbytes $ \ptr -> do
      (len, sockaddr) <- recvBufFrom sock ptr nbytes
      str <- B.packCStringLen (ptr, len)
      return (str, sockaddr)
