{-# LANGUAGE CPP, ForeignFunctionInterface #-}

-- |
-- Module      : Network.Socket.ByteString
-- Copyright   : (c) Johan Tibell 2007
-- License     : BSD-style
--
-- Maintainer  : johan.tibell@gmail.com
-- Stability   : experimental
-- Portability : portable
--
-- A module for efficiently transmitting data over sockets. For detailed
-- documentation, consult your favorite POSIX socket reference. All functions
-- communicate failures by converting the error number to 'System.IO.IOError'.
--
-- This module is made to be imported with 'Network.Socket' like so:
--
-- > import Network.Socket hiding (send, sendTo, recv, recvFrom)
-- > import Network.Socket.ByteString
--
module Network.Socket.ByteString
  ( -- * Send messages on sockets
    -- | Functions for sending messages on sockets
    send
  , sendAll
  , sendMany
  , sendTo
  , sendAllTo
  , sendManyTo

    -- * Receive messages from sockets
    -- | Functions for receiving messages from sockets
  , recv
  , recvFrom
  ) where

import Control.Monad (liftM, when, zipWithM_)
import qualified Data.ByteString as B
import Data.ByteString (ByteString)
import Data.ByteString.Internal (createAndTrim)
import Data.ByteString.Unsafe (unsafeUseAsCStringLen)
import Data.List (iterate)
import Data.Word (Word8)
import Foreign.C.Error (eINTR, getErrno, throwErrno)
import Foreign.C.Types (CChar, CInt, CSize)
import Foreign.Marshal.Alloc (allocaBytes)
import Foreign.Marshal.Array (allocaArray)
import Foreign.Marshal.Utils (with)
import Foreign.Ptr (Ptr, castPtr, nullPtr, plusPtr)
import Foreign.Storable (Storable(..))
import Network.Socket (SockAddr, Socket(..), sendBufTo, recvBufFrom)
import Network.Socket.ByteString.IOVec
import Network.Socket.ByteString.Internal
import Network.Socket.ByteString.MsgHdr
import Network.Socket.ByteString.SockAddr (pokeSockAddr, sizeOfSockAddr)

#if defined(__GLASGOW_HASKELL__)
import GHC.Conc (threadWaitRead, threadWaitWrite)
#  if defined(mingw32_HOST_OS)
import GHC.Handle (readRawBufferPtr, writeRawBufferPtr)
#  endif
#else
import System.IO.Unsafe (unsafePerformIO)
#endif

#ifndef CALLCONV
#  ifdef WITH_WINSOCK
#    define CALLCONV stdcall
#  else
#    define CALLCONV ccall
#  endif
#endif

foreign import CALLCONV unsafe "send"
  c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
foreign import CALLCONV unsafe "recv"
  c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt

-- -----------------------------------------------------------------------------
-- Sending

-- | Send a message on a socket. The socket must be in a connected state.
-- Returns the number of bytes sent. Applications are responsible for ensuring
-- that all data has been sent.
send :: Socket      -- ^ Connected socket
     -> ByteString  -- ^ Data to send
     -> IO Int      -- ^ Number of bytes sent
send (MkSocket s _family _stype _protocol _status) xs =
  unsafeUseAsCStringLen xs $ \(str, len) ->
    liftM fromIntegral $
#if defined(__GLASGOW_HASKELL__) && defined(mingw32_HOST_OS)
      writeRawBufferPtr
        "Network.Socket.ByteString.send"
        (fromIntegral s)
        True
        str
        0
        (fromIntegral len)
#else
#  if !defined(__HUGS__)
      throwErrnoIfMinus1Retry_repeatOnBlock "send"
        (threadWaitWrite (fromIntegral s)) $
#  endif
        c_send s str (fromIntegral len) 0{-flags-}
#endif

-- | Send a message on a socket. The socket must be in a connected state. This
-- function continues to send data until either all data has been sent or an
-- error occurs. If there is an error, an exception is raised, and there is no
-- way to determine how much data was sent.
sendAll :: Socket      -- ^ Connected socket
        -> ByteString  -- ^ Data to send
        -> IO ()
sendAll sock bs = do
  sent <- send sock bs
  when (sent < B.length bs) $ sendAll sock (B.drop sent bs)

-- | Send a multi-part message on a socket. The socket must be in a connected
-- state. The data is sent as if the parts have been concatenated. This
-- function continues to send data until either all data has been sent or an
-- error occurs. If there is an error, an exception is raised, and there is no
-- way to determine how much data was sent.
sendMany :: Socket        -- ^ Connected socket
         -> [ByteString]  -- ^ Data to send
         -> IO ()
sendMany sock@(MkSocket fd _ _ _ _) cs = do
  sent <- sendManyInner
  when (sent < totalLength cs) $ sendMany sock (remainingChunks sent cs)
  where
    sendManyInner =
      liftM fromIntegral . withIOVec cs $ \(iovsPtr, iovsLen) ->
        throwErrnoIfMinus1Retry_repeatOnBlock "writev"
          (threadWaitWrite (fromIntegral fd)) $
          c_writev (fromIntegral fd) iovsPtr (fromIntegral iovsLen)

-- | Send a message on a socket. The recipient can be specified explicitly, so
-- the socket need not be in a connected state. Returns the number of bytes
-- sent. Applications are responsible for ensuring that all data has been sent.
sendTo :: Socket      -- ^ Socket
       -> ByteString  -- ^ Data to send
       -> SockAddr    -- ^ Recipient address
       -> IO Int      -- ^ Number of bytes sent
sendTo sock xs addr =
  unsafeUseAsCStringLen xs $ \(str, len) ->
    sendBufTo sock str len addr

-- | Send a message on a socket. The recipient can be specified explicitly, so
-- the socket need not be in a connected state. This function continues to send
-- data until either all data has been sent or an error occurs. If there is an
-- error, an exception is raised, and there is no way to determine how much
-- data was sent.
sendAllTo :: Socket      -- ^ Socket
          -> ByteString  -- ^ Data to send
          -> SockAddr    -- ^ Recipient address
          -> IO ()
sendAllTo sock xs addr = do
  sent <- sendTo sock xs addr
  when (sent < B.length xs) $ sendAllTo sock (B.drop sent xs) addr

-- | Send a multi-part message on a socket. The recipient can be specified
-- explicitly, so the socket need not be in a connected state. The data is sent
-- as if the parts have been concatenated. This function continues to send data
-- until either all data has been sent or an error occurs. If there is an
-- error, an exception is raised, and there is no way to determine how much
-- data was sent.
sendManyTo :: Socket        -- ^ Socket
           -> [ByteString]  -- ^ Data to send
           -> SockAddr      -- ^ Recipient address
           -> IO ()
sendManyTo sock@(MkSocket fd _ _ _ _) cs addr = do
  sent <- liftM fromIntegral sendManyToInner
  when (sent < totalLength cs) $ sendManyTo sock (remainingChunks sent cs) addr
  where
    sendManyToInner =
      withSockAddr addr $ \addrPtr ->
        withIOVec cs $ \(iovsPtr, iovsLen) -> do
          let msgHdr = MsgHdr
                addrPtr (fromIntegral sizeOfSockAddr)
                iovsPtr (fromIntegral iovsLen)
                nullPtr 0
                0
          with msgHdr $ \msgHdrPtr ->
            throwErrnoIfMinus1Retry_repeatOnBlock "sendmsg"
              (threadWaitWrite (fromIntegral fd)) $
              c_sendmsg (fromIntegral fd) msgHdrPtr 0

-- -----------------------------------------------------------------------------
-- Receiving

-- | Receive a message from a socket. The socket must be in a connected state.
-- This function may return fewer bytes than specified. If the message is
-- longer than the specified length, it may be discarded depending on the type
-- of socket. This function may block until a message arrives.
--
-- Considering hardware and network realities, the maximum number of bytes to
-- receive should be a small power of 2, e.g., 4096.
--
-- For TCP sockets, a zero length return value means the peer has
-- closed its half side of the connection.
recv :: Socket         -- ^ Connected socket
     -> Int            -- ^ Maximum number of bytes to receive
     -> IO ByteString  -- ^ Data received
recv (MkSocket s _ _ _ _) nbytes
    | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.ByteString.recv")
    | otherwise   = createAndTrim nbytes $ recvInner s nbytes

-- | A helper function that loops in the case of EINTR.
recvInner :: CInt -> Int -> Ptr Word8 -> IO Int
recvInner s nbytes ptr = do
    len <- liftM fromIntegral $
#if defined(__GLASGOW_HASKELL__) && defined(mingw32_HOST_OS)
           readRawBufferPtr
             "Network.Socket.ByteString.recvLen"
             (fromIntegral s)
             True
             (castPtr ptr)
             0
             (fromIntegral nbytes)
#else
#  if !defined(__HUGS__)
           throwErrnoIfMinus1Retry_repeatOnBlock "recv"
             (threadWaitRead (fromIntegral s)) $
#  endif
             c_recv s (castPtr ptr) (fromIntegral nbytes) 0
#endif
    if len == -1
      then do
         errno <- getErrno
         if errno == eINTR
           then recvInner s nbytes ptr
           else throwErrno "Network.Socket.ByteString.recv"
      else return len

-- | Receive a message from a socket. The socket need not be in a connected
-- state. Returns @(bytes, address)@ where @bytes@ is a 'ByteString'
-- representing the data received and @address@ is a 'SockAddr' representing
-- the address of the sending socket.
recvFrom :: Socket                     -- ^ Socket
         -> Int                        -- ^ Maximum number of bytes to receive
         -> IO (ByteString, SockAddr)  -- ^ Data received and sender address
recvFrom sock nbytes =
  allocaBytes nbytes $ \ptr -> do
    (len, sockaddr) <- recvBufFrom sock ptr nbytes
    str <- B.packCStringLen (ptr, len)
    return (str, sockaddr)

-- -----------------------------------------------------------------------------
-- Not exported

-- | Suppose we try to transmit a list of chunks @cs@ via a gathering write
-- operation and find that @n@ bytes were sent. Then @remainingChunks n cs@ is
-- list of chunks remaining to be sent.
remainingChunks :: Int -> [ByteString] -> [ByteString]
remainingChunks _ [] = []
remainingChunks i (x:xs) =
  if i < len
    then B.drop i x : xs
    else remainingChunks (i - len) xs
  where
    len = B.length x

-- | @totalLength cs@ is the sum of the lengths of the chunks in the list @cs@.
totalLength :: [ByteString] -> Int
totalLength = sum . map B.length

-- | @withIOVec cs f@ executes the computation @f@, passing as argument a pair
-- consisting of a pointer to a temporarily allocated array of pointers to
-- 'IOVec' made from @cs@ and the number of pointers (@length cs@).
withIOVec :: [ByteString] -> ((Ptr IOVec, Int) -> IO a) -> IO a
withIOVec cs f =
  allocaArray csLen $ \aPtr -> do
    zipWithM_ pokeIov (ptrs aPtr) cs
    f (aPtr, csLen)
  where
    csLen = length cs
    ptrs = iterate (`plusPtr` sizeOf (undefined :: IOVec))
    pokeIov ptr s =
      unsafeUseAsCStringLen s $ \(sPtr, sLen) ->
        poke ptr $ IOVec sPtr (fromIntegral sLen)

-- | @withSockAddr addr f@ executes the computation @f@, passing as argument a
-- pointer to a temporarily allocated block of memory into which @addr@ has
-- been marshalled.
withSockAddr :: SockAddr -> (Ptr SockAddr -> IO a) -> IO a
withSockAddr addr f =
  allocaBytes sizeOfSockAddr $ \addrPtr -> do
    pokeSockAddr addrPtr addr
    f addrPtr
